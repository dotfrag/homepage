---
import type { MarkdownHeading } from "astro";

interface Props {
	position?: "left" | "right";
	headings: MarkdownHeading[];
}

const { position = "right", headings } = Astro.props;

const filteredHeadings = headings.filter((heading) => heading.depth <= 3);
---

<aside
	data-pagefind-ignore
	class="max-md:bg-surface-0 mb-6 shrink-0 max-md:rounded-sm max-md:p-2 md:mb-0 md:block md:w-50"
>
	<nav class="sticky top-8" aria-label="Table of Contents">
		<h2 class="bg-base/80 rounded-sm px-2 py-1 text-xl font-semibold md:hidden">
			Table of Contents
		</h2>
		<ul
			class:list={[
				{
					"pr-0 md:border-l-2": position === "right",
					"pl-0 md:border-r-2": position === "left",
				},
				"md:border-lavender/40 md:border-t-2 md:p-1 md:pr-0",
			]}
		>
			{
				filteredHeadings.map((heading) => (
					<li
						class:list={[
							{
								"px-2 font-semibold has-[+li.px-2]:mb-1": heading.depth === 2,
								"pr-2 pl-6 text-sm": heading.depth === 3,
							},
							"relative py-0.5 transition",
						]}
					>
						<a href={`#${heading.slug}`} class="block">
							{heading.text}
						</a>
					</li>
				))
			}
		</ul>
	</nav>
</aside>

<script>
	// const observerCallback = (entries: IntersectionObserverEntry[]) => {
	// 	entries.forEach((entry) => {
	// 		const id = entry.target.getAttribute("id");
	// 		const tocLink = document.querySelector(`a[href="#${id}"]`);
	// 		if (entry.isIntersecting) {
	// 			tocLink?.classList.add("text-maroon");
	// 		} else {
	// 			tocLink?.classList.remove("text-maroon");
	// 		}
	// 	});
	// };
	// const observer = new IntersectionObserver(observerCallback);
	// document
	// 	.querySelector("article")
	// 	?.querySelectorAll("h1, h2, h3, h4, h5, h6")
	// 	.forEach((heading) => {
	// 		observer.observe(heading);
	// 	});

	// https://dev.to/teej/building-a-table-of-contents-with-the-intersection-observer-api-3b3g
	const TableOfContents = {
		container: document.querySelector("aside") as HTMLElement,
		links: null as HTMLAnchorElement[] | null,
		headings: null as HTMLElement[] | null,
		intersectionOptions: {
			rootMargin: "0px",
			threshold: 1,
		},
		previousSection: null as string | null,
		observer: null as IntersectionObserver | null,

		init() {
			this.handleObserver = this.handleObserver.bind(this);

			this.setUpObserver();
			this.findLinksAndHeadings();
			this.observeSections();

			// ["click", "ontouchstart"].forEach((evt) =>
			// 	element.addEventListener(evt, dosomething, false)
			// );

			this.links?.forEach((link) => {
				link.addEventListener("click", this.handleLinkClick.bind(this));
			});
		},

		handleLinkClick(e: Event) {
			// e.preventDefault(); // this disables url change which is not ideal for usability and SEO
			const target = e.target as HTMLAnchorElement;
			let id = target.getAttribute("href")?.replace("#", "");

			let section = this.headings?.find((heading) => {
				return heading.getAttribute("id") === id;
			});

			section?.setAttribute("tabindex", "-1");
			section?.focus();

			window.scroll({
				behavior: "smooth",
				top: section?.offsetTop ?? 0 - 14,
			});

			this.container.classList.remove("toc-is-active");
		},

		handleObserver(entries: IntersectionObserverEntry[]) {
			entries.forEach((entry) => {
				let href = `#${entry.target.getAttribute("id")}`,
					link = this.links?.find((l) => l.getAttribute("href") === href);

				if (entry.isIntersecting && entry.intersectionRatio >= 1) {
					link?.classList.add("toc-is-visible");
					this.previousSection = entry.target.getAttribute("id");
				} else {
					link?.classList.remove("toc-is-visible");
				}

				this.highlightFirstActive();
			});
		},

		highlightFirstActive() {
			let firstVisibleLink = this.container.querySelector(".toc-is-visible");

			this.links?.forEach((link) => {
				link.parentElement?.classList.remove("toc-is-active");
			});

			if (firstVisibleLink) {
				firstVisibleLink.parentElement?.classList.add("toc-is-active");
			}

			if (!firstVisibleLink && this.previousSection) {
				this.container
					.querySelector(`a[href="#${this.previousSection}"]`)
					?.parentElement?.classList.add("toc-is-active");
			}
		},

		observeSections() {
			this.headings?.forEach((heading) => {
				this.observer?.observe(heading);
			});
		},

		setUpObserver() {
			this.observer = new IntersectionObserver(
				this.handleObserver,
				this.intersectionOptions,
			);
		},

		findLinksAndHeadings() {
			this.links = [...this.container.querySelectorAll("a")];
			// @ts-ignore
			this.headings = this.links.map((link) => {
				let id = link.getAttribute("href");
				// @ts-ignore
				return document.querySelector(id);
			});
		},
	};

	TableOfContents.init();
</script>
